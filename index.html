import { useState, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

interface ConvertedProposal {
  projectCode: string;
  contractNumber: string;
  classId: string;
  projectName: string;
  trainingProgram: string;
  trainingStartDate: string;
  trainingEndDate: string;
  customerName: string;
  typeOfService: string;
  durationDays: string;
}

export default function Converter() {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const textAreaRef = useRef<HTMLTextAreaElement>(null);
  const [convertedData, setConvertedData] = useState<ConvertedProposal[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [fileName, setFileName] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("upload");

  const parseTableData = (content: string): ConvertedProposal[] | null => {
    try {
      // Try to parse as HTML
      if (content.includes("<table") || content.includes("<tr")) {
        return parseHTMLTable(content);
      }
      
      // Try to parse as CSV
      if (content.includes(",")) {
        return parseCSVTable(content);
      }

      // Try to parse as tab-separated (pasted from Excel)
      if (content.includes("\t")) {
        return parseTabSeparated(content);
      }

      return null;
    } catch (err) {
      console.error("Error parsing table:", err);
      return null;
    }
  };

  const parseHTMLTable = (htmlContent: string): ConvertedProposal[] | null => {
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlContent, "text/html");
      let table = doc.querySelector("table");
      if (!table) return null;

      const headers: string[] = [];
      const headerCells = table.querySelectorAll("thead tr th, thead tr td, tr:first-child th, tr:first-child td");
      
      if (headerCells.length === 0) {
        const firstRow = table.querySelector("tr");
        if (firstRow) {
          firstRow.querySelectorAll("th, td").forEach((cell) => {
            headers.push(cell.textContent?.trim() || "");
          });
        }
      } else {
        headerCells.forEach((cell) => {
          headers.push(cell.textContent?.trim() || "");
        });
      }

      const rows: string[][] = [];
      const allRows = table.querySelectorAll("tbody tr, tr");
      
      allRows.forEach((row) => {
        const cells: string[] = [];
        row.querySelectorAll("td, th").forEach((cell) => {
          cells.push(cell.textContent?.trim() || "");
        });
        
        if (cells.length > 0 && cells.some(c => c.length > 0)) {
          const isHeaderRow = Array.from(row.querySelectorAll("th")).length === cells.length;
          if (!isHeaderRow) {
            rows.push(cells);
          }
        }
      });

      if (headers.length === 0 && rows.length > 0) {
        rows.shift();
      }

      if (headers.length === 0 || rows.length === 0) {
        return null;
      }

      return convertTableToProposals(headers, rows);
    } catch (err) {
      return null;
    }
  };

  const parseCSVTable = (csvContent: string): ConvertedProposal[] | null => {
    try {
      const lines = csvContent.trim().split("\n");
      if (lines.length < 2) return null;

      const headers = lines[0].split(",").map(h => h.trim());
      const rows = lines.slice(1).map(line => line.split(",").map(c => c.trim()));

      if (headers.length === 0 || rows.length === 0) return null;

      return convertTableToProposals(headers, rows);
    } catch (err) {
      return null;
    }
  };

  const parseTabSeparated = (content: string): ConvertedProposal[] | null => {
    try {
      const lines = content.trim().split("\n");
      if (lines.length < 2) return null;

      const headers = lines[0].split("\t").map(h => h.trim());
      const rows = lines.slice(1).map(line => line.split("\t").map(c => c.trim()));

      if (headers.length === 0 || rows.length === 0) return null;

      return convertTableToProposals(headers, rows);
    } catch (err) {
      return null;
    }
  };

  const findColumnIndex = (headerName: string, headers: string[]): number => {
    const lowerName = headerName.toLowerCase();
    return headers.findIndex(h => h.toLowerCase().includes(lowerName));
  };

  const convertTableToProposals = (headers: string[], rows: string[][]): ConvertedProposal[] => {
    // Encontrar índices das colunas na tabela de entrada
    const projectCodeIndex = findColumnIndex("project code", headers) >= 0 ? findColumnIndex("project code", headers) : 0;
    const contractNumberIndex = findColumnIndex("contract", headers) >= 0 ? findColumnIndex("contract", headers) : 6;
    const classIdIndex = findColumnIndex("class", headers) >= 0 ? findColumnIndex("class", headers) : 7;
    const projectNameIndex = findColumnIndex("project name", headers) >= 0 ? findColumnIndex("project name", headers) : 3;
    const trainingProgramIndex = findColumnIndex("training program", headers) >= 0 ? findColumnIndex("training program", headers) : 8;
    const startDateIndex = findColumnIndex("start date", headers) >= 0 ? findColumnIndex("start date", headers) : 10;
    const endDateIndex = findColumnIndex("end date", headers) >= 0 ? findColumnIndex("end date", headers) : 11;
    const customerIndex = findColumnIndex("customer", headers) >= 0 ? findColumnIndex("customer", headers) : 1;
    const durationIndex = findColumnIndex("duration", headers) >= 0 ? findColumnIndex("duration", headers) : 13;

    return rows.map((row) => {
      const trainingProgram = row[trainingProgramIndex] || "";
      
      return {
        projectCode: row[projectCodeIndex] || "",
        contractNumber: row[contractNumberIndex] || "",
        classId: row[classIdIndex] || "",
        projectName: row[projectNameIndex] || "",
        trainingProgram: trainingProgram,
        trainingStartDate: row[startDateIndex] || "",
        trainingEndDate: row[endDateIndex] || "",
        customerName: row[customerIndex] || "",
        typeOfService: "Training Delivery",
        durationDays: row[durationIndex] || "",
      };
    });
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setError(null);
    setSuccess(null);
    setLoading(true);
    setFileName(file.name);

    if (file.type.startsWith('image/')) {
      handleImageUpload(file);
    } else {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const content = e.target?.result as string;
          const proposals = parseTableData(content);

          if (!proposals || proposals.length === 0) {
            setError("Nenhuma tabela encontrada. Certifique-se de que o arquivo contém uma tabela válida.");
            setLoading(false);
            return;
          }

          setConvertedData(proposals);
          setSuccess(`✓ ${proposals.length} linhas convertidas com sucesso!`);
        } catch (err) {
          setError(`Erro: ${err instanceof Error ? err.message : "Erro desconhecido"}`);
        } finally {
          setLoading(false);
        }
      };

      reader.readAsText(file);
    }
  };

  const handleImageUpload = async (file: File) => {
    try {
      const formData = new FormData();
      formData.append('image', file);

      const response = await fetch('/api/proposals/extract-table-from-image', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Erro ao processar imagem');
      }

      const { tableData } = await response.json();
      const proposals = parseTableData(tableData);

      if (!proposals || proposals.length === 0) {
        setError('Nenhuma tabela encontrada na imagem. Tente uma imagem mais clara.');
        setLoading(false);
        return;
      }

      setConvertedData(proposals);
      setSuccess(`✓ ${proposals.length} linhas extraídas da imagem com sucesso!`);
    } catch (err) {
      setError(`Erro: ${err instanceof Error ? err.message : "Erro ao processar imagem"}`);
    } finally {
      setLoading(false);
    }
  };

  const handlePasteTable = () => {
    if (!textAreaRef.current?.value) {
      setError("Cole uma tabela no campo de texto");
      return;
    }

    setError(null);
    setSuccess(null);
    setLoading(true);

    try {
      const content = textAreaRef.current.value;
      const proposals = parseTableData(content);

      if (!proposals || proposals.length === 0) {
        setError("Nenhuma tabela encontrada. Cole uma tabela válida (HTML, CSV ou do Excel).");
        setLoading(false);
        return;
      }

      setConvertedData(proposals);
      setSuccess(`✓ ${proposals.length} linhas convertidas com sucesso!`);
      setFileName("Tabela colada");
    } catch (err) {
      setError(`Erro: ${err instanceof Error ? err.message : "Erro desconhecido"}`);
    } finally {
      setLoading(false);
    }
  };

  const handleGenerateExcel = async () => {
    if (convertedData.length === 0) {
      setError("Nenhum dado para converter.");
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/proposals/generate-excel", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ proposals: convertedData }),
      });

      if (!response.ok) throw new Error("Erro ao gerar Excel");

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const projectCode = convertedData[0]?.projectCode || 'export';
      const projectName = convertedData[0]?.projectName || 'proposal';
      const sanitizedName = projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      a.download = `${projectCode} - ${sanitizedName}.xlsx`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      // Atualizar estatísticas
      const savedStats = JSON.parse(localStorage.getItem("proposalStats") || '{"conversions":0,"lines":0,"successRate":100,"avgTime":2}');
      savedStats.conversions += 1;
      savedStats.lines += convertedData.length;
      localStorage.setItem("proposalStats", JSON.stringify(savedStats));

      // Extrair informações do primeiro projeto
      const firstProject = convertedData[0];
      const excelFileName = `${firstProject.projectCode} - ${firstProject.projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.xlsx`;

      // Adicionar ao histórico
      const newHistoryItem = {
        id: Date.now().toString(),
        fileName: fileName || "Tabela colada",
        date: new Date().toLocaleDateString("pt-BR"),
        time: new Date().toLocaleTimeString("pt-BR"),
        rows: convertedData.length,
        status: "Concluído",
        projectCode: firstProject.projectCode || "-",
        projectName: firstProject.projectName || "Sem nome",
        excelFile: excelFileName,
      };

      const savedHistory = JSON.parse(localStorage.getItem("proposalHistory") || "[]");
      savedHistory.unshift(newHistoryItem);
      localStorage.setItem("proposalHistory", JSON.stringify(savedHistory));

      setSuccess("✓ Arquivo Excel gerado e baixado com sucesso!");
    } catch (err) {
      setError(`Erro: ${err instanceof Error ? err.message : "Erro desconhecido"}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-gray-900">Conversor de Propostas</h1>
        <p className="text-gray-600 mt-2">Converta tabelas em propostas Excel formatadas em segundos</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Input Section */}
        <Card className="lg:col-span-1 shadow-lg">
          <CardHeader>
            <CardTitle className="text-lg">Carregar Dados</CardTitle>
            <CardDescription>HTML, CSV, Excel ou copiar/colar</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="upload">Arquivo</TabsTrigger>
                <TabsTrigger value="paste">Colar</TabsTrigger>
              </TabsList>

              <TabsContent value="upload" className="space-y-4 mt-4">
                <div
                  className="border-2 border-dashed border-blue-300 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".html,.htm,.csv,.xlsx,.xls,.png,.jpg,.jpeg,.gif,.bmp,.webp"
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                  <svg className="w-8 h-8 text-blue-500 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                  </svg>
                  <p className="font-semibold text-gray-700 text-sm">Clique para carregar</p>
                  <p className="text-xs text-gray-500">HTML, CSV, Excel ou Imagem</p>
                </div>
              </TabsContent>

              <TabsContent value="paste" className="space-y-4 mt-4">
                <textarea
                  ref={textAreaRef}
                  placeholder="Cole sua tabela aqui (do Excel, HTML, ou CSV)..."
                  className="w-full h-40 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                />
                <Button
                  onClick={handlePasteTable}
                  disabled={loading}
                  className="w-full bg-blue-600 hover:bg-blue-700"
                >
                  {loading ? "Processando..." : "Processar Tabela"}
                </Button>
              </TabsContent>
            </Tabs>

            {fileName && (
              <div className="bg-blue-50 p-3 rounded text-sm text-blue-900 border border-blue-200">
                📄 {fileName}
              </div>
            )}

            {error && (
              <Alert className="border-red-300 bg-red-50">
                <AlertDescription className="text-red-800 text-sm">{error}</AlertDescription>
              </Alert>
            )}

            {success && (
              <Alert className="border-green-300 bg-green-50">
                <AlertDescription className="text-green-800 text-sm">{success}</AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>

        {/* Data Preview */}
        <Card className="lg:col-span-2 shadow-lg">
          <CardHeader>
            <CardTitle className="text-lg">Visualização</CardTitle>
            <CardDescription>{convertedData.length} linhas convertidas</CardDescription>
          </CardHeader>
          <CardContent>
            {convertedData.length > 0 ? (
              <Tabs defaultValue="table" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="table">Tabela</TabsTrigger>
                  <TabsTrigger value="cards">Cards</TabsTrigger>
                </TabsList>
                
                <TabsContent value="table" className="mt-4">
                  <div className="overflow-x-auto max-h-96">
                    <table className="w-full text-sm border-collapse">
                      <thead className="bg-blue-500 text-white sticky top-0">
                        <tr>
                          <th className="px-3 py-2 text-left border">Project 
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)

